<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fitting with lmfit - mike.depalatis.net</title>
<link rel="stylesheet" href="/css/inter.css">
<link rel="stylesheet" href="/css/new.css">
<link rel="stylesheet" href="/css/codehilite.css">
</head>
<body>
<header>
<h1>mike.depalatis.net</h1>
<nav>
<a href="/index.html">Home</a>
/
<a href="/blog/index.html">Articles</a>
/
<a href="/resources.html">Resources</a>
</nav>
</header>


<h1>Fitting with lmfit</h1>
<p>General-purpose fitting in Python can sometimes be a bit more
challenging than one might at first suspect given the robust nature of
tools like Numpy and Scipy. First we had <code>leastsq</code>. It works, although
often requires a bit of manual tuning of initial guesses and <em>always</em>
requires manual calculation of standard error from a covariance matrix
(which isn't even one of the return values by default). Later we got
<code>curve_fit</code> which is a bit more user friendly and even estimates and
returns standard error for us by default! Alas, <code>curve_fit</code> is just a
convenience wrapper on top of <code>leastsq</code> and suffers from some of the
same general headaches.</p>
<p>These days, we have the wonderful <a href="https://github.com/lmfit/lmfit-py/">lmfit</a> package. Not only can lmfit
make fitting more user friendly, but it also is quite a bit more robust
than using scipy directly. The documentation is thorough and rigorous,
but that can also mean that it can be a bit overwhelming to get started
with it. Here I work through a basic example in two slightly different
ways in order to demonstrate how to use it.</p>
<h2>Generating the data</h2>
<p>Let's assume we have data that resembles a decaying sine wave (e.g., a
damped oscillator). lmfit has quite a few pre-defined models, but this
is not one of them. We can simulate the data with the following code:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="mf">2.5</span><span class="p">)</span>
</code></pre></div>

<p>Real data is noisy, so let's add some noise:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>

<span class="n">y</span> <span class="o">+=</span> <span class="n">npr</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="n">npr</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span>
</code></pre></div>

<p>The resulting data:</p>
<p><img alt="Decaying sine generated data" src="../img/lmfit/data.svg"></p>
<h2>Using models</h2>
<p>The easiest way to work with lmfit is to ignore the <code>lmfit.minimize</code>
function shown in the "Getting Started" section of the documentation and
instead jump straight to the higher-level (and more useful) <code>Model</code>
class. For one-time fitting, the <code>lmfit.models.ExpressionModel</code> class is
provided. When creating a new <code>ExpressionModel</code>, you simply pass a
string that is interpreted as a Python expression. For our decaying sine
example, we might do this:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">lmfit</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">ExpressionModel</span><span class="p">(</span><span class="s2">&quot;ampl * sin((x - x0)*freq) * exp(-x/tau) + offset&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Let's make our initial guess for performing the fit under the constraint
that the offset is fixed at 0:</p>
<div class="codehilite"><pre><span></span><code><span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">make_params</span><span class="p">(</span><span class="n">ampl</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">params</span><span class="p">[</span><span class="s2">&quot;offset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">vary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>

<p>To fit, we pass the data and the parameters as arguments and the
independent variable as a keyword argument:</p>
<div class="codehilite"><pre><span></span><code><span class="n">fit</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
</code></pre></div>

<p>To visually check if the fit is good, lmfit provides both <code>plot_fit</code> and
<code>plot_residuals</code> methods for model instances. The former shows the data,
the initial guess, and its found best fit:</p>
<p><img alt="Result of the ExpressionModel fit" src="../img/lmfit/fit-expression-model.svg"></p>
<p>We can also see the found parameters with standard errors and goodness
of fit data with a fit report (<code>print(model.fit_report())</code>):</p>
<div class="codehilite"><pre><span></span><code>[[Model]]
    Model(_eval)
[[Fit Statistics]]
    # function evals   = 102
    # data points      = 100
    # variables        = 4
    chi-square         = 1.337
    reduced chi-square = 0.014
    Akaike info crit   = -419.379
    Bayesian info crit = -408.959
[[Variables]]
    ampl:     1.02147340 +/- 0.068013 (6.66%) (init= 1)
    offset:   0 (fixed)
    tau:      2.53669407 +/- 0.239335 (9.43%) (init= 1)
    x0:      -0.00823894 +/- 0.012256 (148.76%) (init= 0)
    freq:     4.98932400 +/- 0.035399 (0.71%) (init= 10)
[[Correlations]] (unreported correlations are &lt;  0.100)
    C(ampl, tau)                 = -0.718
    C(x0, freq)                  =  0.684
    C(ampl, x0)                  =  0.139
</code></pre></div>

<h2>Reusable models</h2>
<p>For improved reusability of models, a better approach is to subclass
<code>lmfit.models.Model</code> directly. This allows us to implement a <code>guess</code>
method to automate creating initial guesses. Following the pattern used
in defining the models in the <code>lmfit.models</code> module, we can define our
decaying sine model like so:</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">DecayingSineModel</span><span class="p">(</span><span class="n">lmfit</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">decaying_sine</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ampl</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ampl</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DecayingSineModel</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">decaying_sine</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">guess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_params</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">pset</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="n">param</span><span class="p">)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
        <span class="n">pset</span><span class="p">(</span><span class="s2">&quot;ampl&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">pset</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">pset</span><span class="p">(</span><span class="s2">&quot;freq&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pset</span><span class="p">(</span><span class="s2">&quot;x0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pset</span><span class="p">(</span><span class="s2">&quot;tau&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">update_param_vals</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div>

<p>Note that the point of the prefix is so that composite models can be
constructed (the prefix prevents namespace clashes). Now we can fit as
before but guess the starting parameters without thinking about it:</p>
<div class="codehilite"><pre><span></span><code><span class="n">model</span> <span class="o">=</span> <span class="n">DecayingSineModel</span><span class="p">()</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">guess</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
</code></pre></div>

<p>which results in a similar fit as before:</p>
<p><img alt="Result of the DecayingSineModel fit" src="../img/lmfit/fit-decaying-sine-model.svg"></p>
<h2>Extracting data from the fit</h2>
<p>In many cases we might want to extract parameters and standard error
estimates programatically rather than by reading the fit report (e.g.,
if the fit will be used to produce a data point on another plot, then
the standard error can be used for computing error bars). This is all
included in the <code>fit</code> result via its <code>params</code> attribute. We can print
the parameter values and errors like this:</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;+/-&quot;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
</code></pre></div>

<h2>Final thoughts</h2>
<p>I've only scratched the surface of <code>lmfit</code>'s features, but the examples
here demonstrate a good portion of the daily requirements of working
with data from an experiment. As alluded to earlier, <code>lmfit</code> comes with
many <a href="https://lmfit.github.io/lmfit-py/builtin_models.html#builtin-models-chapter">built-in models</a> which makes it a pleasure to use for peak
fitting (something that is often particularly difficult when using scipy
directly).</p>
<p>Finally, although <code>lmfit</code> can handle linear models just fine, I would
instead recommend the <a href="http://statsmodels.sourceforge.net/">statsmodels</a> package. Using the power of
<a href="http://pandas.pydata.org/">pandas</a> <code>DataFrame</code>s, models can be defined in a similar manner as
with <code>lmfit</code>'s <code>ExpressionModel</code>s.</p>
<p>A Jupyter notebook containing the above examples can be found
<a href="../notebooks/lmfit_20160703.ipynb">here</a>.</p>

</body>
</html>
