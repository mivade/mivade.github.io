<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flask and server-sent events - mike.depalatis.net</title>
<link rel="stylesheet" href="/css/inter.css">
<link rel="stylesheet" href="/css/new.css">
<link rel="stylesheet" href="/css/codehilite.css">
</head>
<body>
<header>
<h1>mike.depalatis.net</h1>
<nav>
<a href="/index.html">Home</a>
/
<a href="/blog/index.html">Articles</a>
/
<a href="/resources.html">Resources</a>
</nav>
</header>


<h1>Flask and server-sent events</h1>
<p>I recently discovered the existence of the HTML5
<a href="https://en.wikipedia.org/wiki/Server-sent_events">server-sent events</a> standard. Although it lacks the
bidirectional communications of a websocket, SSE is perfect for the
publish-subscribe networking pattern. This pattern just so happens to
fit in conveniently with writing software to remotely monitor hardware
that many people might want to check in on at the same time.</p>
<p>In order to try SSE out within a <a href="http://flask.pocoo.org/">Flask</a> framework, I put together a
simple <a href="https://github.com/mivade/flask-sse-demo">demo app</a> using <a href="http://gevent.org/">gevent</a>. The core of the demo on the
Python side looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">event</span><span class="p">():</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s1">&#39;data: &#39;</span> <span class="o">+</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span>
        <span class="n">gevent</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;index.html&#39;</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/stream/&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">stream</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="n">event</span><span class="p">(),</span> <span class="n">mimetype</span><span class="o">=</span><span class="s2">&quot;text/event-stream&quot;</span><span class="p">)</span>
</code></pre></div>

<p>This can be run either using gevent's WSGI server or <a href="http://gunicorn.org/">gunicorn</a>
using gevent workers.</p>
<p><strong>Update 2016-04-21</strong>: There is now a very nice Flask extension called
<a href="https://flask-sse.readthedocs.org/en/latest/">Flask-SSE</a> which handles all of this for you. It additionally
supports the concept of channels in order to fine tune what
notifications a given client receives.</p>

</body>
</html>
