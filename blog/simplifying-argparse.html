<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simplifying argparse usage with subcommands - mike.depalatis.net</title>
<link rel="stylesheet" href="/css/inter.css">
<link rel="stylesheet" href="/css/new.css">
<link rel="stylesheet" href="/css/codehilite.css">
</head>
<body>
<header>
<h1>mike.depalatis.net</h1>
<nav>
<a href="/index.html">Home</a>
/
<a href="/blog/index.html">Articles</a>
/
<a href="/resources.html">Resources</a>
</nav>
</header>


<h1>Simplifying argparse usage with subcommands</h1>
<p>One of the best things about Python is its standard library: it's
frequently possible to create complex applications while requiring few
(if any) external dependencies. For example, command line interfaces
can be easily built with the <code>argparse</code> module. Despite this, there
exist several alternative, third-party modules (e.g., <a href="http://docopt.org/">docopt</a>,
<a href="http://click.pocoo.org/">click</a>, and <a href="http://begins.readthedocs.io/en/latest/">begins</a>). These all tend to share similar
motivations: while <code>argparse</code> is powerful, it is by inherently verbose
and is therefore cumbersome to use for more complex CLIs which use
advanced features such as subcommands. Nevertheless, I tend to prefer
sticking with <code>argparse</code> in part because I am already familiar with
the API and because using it means I don't need to bring in another
dependency from PyPI just to add a small bit of extra
functionality. The good news is that with a simple decorator and a
convenience function, writing CLIs with subcommands in <code>argparse</code> is
pretty trivial and clean.</p>
<p>Start by creating a parser and subparsers in <code>cli.py</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">argparse</span> <span class="kn">import</span> <span class="n">ArgumentParser</span>

<span class="n">cli</span> <span class="o">=</span> <span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">subparsers</span> <span class="o">=</span> <span class="n">cli</span><span class="o">.</span><span class="n">add_subparsers</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="s2">&quot;subcommand&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Note that we are storing the name of the called subcommand so that we
can later print help if either no subcommand is given or if an
unrecognized one is. Now we can define a decorator to turn a function
into a subcommand:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">subcommand</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">parent</span><span class="o">=</span><span class="n">subparsers</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">add_parser</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">arg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decorator</span>
</code></pre></div>

<p>What this does is take the wrapped function and use its name and
docstring for the subcommand name and help string, respectively. Next
it automatically adds arguments for the subcommand from a list passed
to the decorator. In order to dispatch the command later, the usual
<code>parser.set_defaults</code> method is used to store the function itself in
the <code>func</code> variable.</p>
<p>In the simplest case, we can create a subcommand which requires no
arguments as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@subcommand</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">nothing</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nothing special!&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Meanwhile, in our main function, we dispatch the subcommand as follows:</p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">cli</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">subcommand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cli</span><span class="o">.</span><span class="n">print_help</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
</code></pre></div>

<p>Now running <code>python cli.py nothing</code> will run the <code>nothing</code> function
and simply print <code>Nothing special!</code> to stdout.</p>
<p>More often, subcommands require their own set of options. In the
definition of the <code>subcommand</code> decorator above, these options can be
given as a list of length-2 lists that contain the <a href="https://docs.python.org/3/library/argparse.html#the-add-argument-method">name or flags</a>
for the argument and all keyword arguments used by
<code>ArgumentParser.add_argument</code>. This is a bit cumbersome as is, so it's
useful to define a small helper function that takes arguments just
like <code>ArgumentParser.add_argument</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">argument</span><span class="p">(</span><span class="o">*</span><span class="n">name_or_flags</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">([</span><span class="o">*</span><span class="n">name_or_flags</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">)</span>
</code></pre></div>

<p>Now we can define commands with arguments like so:</p>
<div class="codehilite"><pre><span></span><code><span class="nd">@subcommand</span><span class="p">([</span><span class="n">argument</span><span class="p">(</span><span class="s2">&quot;-d&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Debug mode&quot;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>


<span class="nd">@subcommand</span><span class="p">([</span><span class="n">argument</span><span class="p">(</span><span class="s2">&quot;-f&quot;</span><span class="p">,</span> <span class="s2">&quot;--filename&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;A thing with a filename&quot;</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>


<span class="nd">@subcommand</span><span class="p">([</span><span class="n">argument</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Name&quot;</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</code></pre></div>

<p>That's all there is to it! Quite a bit better than <a href="https://docs.python.org/3/library/argparse.html#sub-commands">the default way</a>
to build a CLI with subcommands. The full example can be found <a href="https://gist.github.com/mivade/384c2c41c3a29c637cb6c603d4197f9f">here</a>.</p>

</body>
</html>
